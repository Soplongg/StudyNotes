# GC如何判断对象可以被回收

## 1. 引用计数法

​	每一个对象都有一个引用计数属性，当新增一个引用的时候+1，引用释放的时候-1，当计数为0的时候可以回收。

> 引用计数法可以出现A引用了B，B又引用了A,当两个都不再使用的使用,因为相互引用的原因,计数器 = 1，永远无法被回收

## 2. 可达性分析法

​	从 GC Roots  开始往下搜索,搜索所走过的路径称为引用链。当一个对象没有到 GC Roots 没有任何引用链连接时，则证明该对象是没有使用的，那么虚拟机就判断是可回收对象。

### GC Roots的对象有：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

​       可达性算法中不可达对象并非是立即死亡，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots 相连接的引用链，第二次是在由虚拟机自动建立的Finalizer中判断是否需要执行finalize( )方法。

​		当对象变成（GC Roots）不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。若已覆盖且对象未执行finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达则进行回收，否则，对象---------"复活"

> 每个对象只能触发一次finalize方法
>
> finalize方法运行代价高，不确定性大，无法保证各个对象的调用顺序，不推荐使用



# Java类加载器

JDK自带三个类加载器：boostrap ClassLoader、ExtClassLoader、AppClassLoader

boostrap ClassLoader 是 ExtClassLoader的父类加载器，负责加载%JAVA_HOME%/lib下的jar包和class文件。

ExtClassLoader 是 APPClassLoader  的 父类加载器，负责加载%JAVA_HOME%/lib/ext下的jar包和class文件。

APPClassLoader 是 自定义加载器 的 父类加载器,负责加载classpath路径下的类文件同时还是系统加载器，线程上下文加载器。

自定义加载器的实现方法是继承ClassLoader。

# Java类加载

![image-20210811145151309](E:\学习笔记\img\java类加载1.png)

## 1.Java的类加载的全过程是什么样的？

Java的类加载器：AppClassLoader -> ExtClassLoader -> BootStrap ClassLoader   (parent属性,并非是继承关系)

Java 的类加载器的继承关系：AppClassLoader , ExtClassLoader  ->   URLClassLoader  ->  SecureClassLoader ->  ClassLoader

类加载过程：  加载  ->  连接   ->  初始化 

- 加载：把 Java的字节码数据加载到JVM内存中，并映射成JVM认可的数据结构。
- 连接：分为三个小阶段
  1. 验证：检查加载到的字节信息是否符合JVM规范。
  2. 准备：创建类或者接口的静态变量，并赋予初始值。
  3. 解析：把符号引用转为直接引用
- 初始化：对静态变量、静态代码块执行初始化工作。

> 类加载器就是寻找类或者字节码文件进行解析并构造成JVM内部对象的一个组件。就是将类装入JVM。

## 2.双亲委托机制是什么?

<img src="E:\学习笔记\img\java类加载2.png" alt="img" style="zoom:50%;" />

每个类加载器对加载过得类，会存入缓存中，当要加载类的时候，会去缓存中查询是否已经加载过。

双亲委托机制：向上委托查找，向下委托加载。作用：保护Java底层的类不会被应用程序覆盖。

# Java内存模型

![image-20210811174252194](E:\学习笔记\img\Java内存模型.png)

nonheap是方法区的别名,是各个线程共享的内存区域,用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

![image-20210811181850006](E:\学习笔记\img\JVM内存空间.png)

# STW是什么

STW:Stop-The-World。在垃圾回收算法执行过程中，将JVM内存冻结的一种状态。在STW状态下，JAVA所有的线程都停止执行除了-----GC线程。在此期间，native方法也是可以执行的，但是不能与JVM进行交互。GC各种算法优化的重点就是减少STW，同时这也是JVM调优的重点。

# JVM有哪些垃圾回收器

## 1.Serial  串行

当需要GC执行的时候，进入到STW状态，线程暂停等待GC执行完毕再继续执行。

这个垃圾回收器是早期的垃圾回收器，只有一个线程执行GC。在多CPU架构的情况下，性能效率严重降低，只适用于几十兆的内存空间。

## 2.Parallel 并行

在Serial 串行基础上，优化为多个线程执行GC。

> PS + PO 这种组合是JDK1.8默认的垃圾回收器。

# ArrayList和LinkedList的区别

1. ArrayList底层是由数组实现的，LinkedList底层是由链表实现的。
2. ArrayList更擅长随机访问，LinkedList更擅长与添加删除。
3. 二者都实现了List接口，LinkedList还实现了Queue接口，可以当做队列使用。ArrayList实现了RandomAccess接口，支持随机访问也就是按数组下标访问。
4. ArrayList在add( )的时候会扩容,如果指定位置,会因为需要移动其他元素的位置导致时间复杂度上升。LinkedList只需要插入节点即可。

# String、StringBuffer、StringBuilder的区别

1. String是不可变的，如果修改则会产生一个新的对象。StringBuffer和StringBuilder都是可变的。
2. StringBuilder都是线程不安全的，StringBuffer是线程安全的。单线程的情况下，StringBuilder效率更高。
3. StringBuffer和StringBuffer在1.7以前都是使用char数组，之后修改成了byte数组。 

# ThreadLocal

1. ThreadLocal是Java提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据。
2. ThreadLocal底层是通过ThreadLocalMap来实现的，每一个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key就是ThreadLocal对象，Map的value就是缓存的值。
3. 如果再线程池中使用ThreadLocal会造成内存泄漏,因为当ThreadLocal对象使用完后,应该要把设置的key，value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也不会被回收，从而出现内存泄漏，解决的方法是，在使用了ThreadLocal对象后，手动调用ThreadLocal中的remove方法，手动清除掉Entry对象。
4. ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享一个连接）

# JVM中哪些是共享区，哪些可以作为 GC Root

<img src="E:\学习笔记\img\JVM运行时数据区.png" alt="image-20210816211657198" style="zoom: 67%;" />

1. 方法区和堆是所有线程共享的，栈、本地方法栈、程序计数器是每个线程独有的。
2. 什么是GC Root：JVM在进行回收时候，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接查找这些“垃圾”对象是比较耗时的。所以，反过来，先找“非垃圾”对象，也就是有被引用的对象，那么就需要从某些“根”开始去寻找，根据这些“根”的引用路径找到正常的对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如：栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等都可以作为GC Root。

# 线程之间如何进行通讯

1. 线程之间可以通过共享内存或基于网络进行通讯。
2. 如果是通过共享内存进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒。
3. Java中，wait和notify分别是阻塞和唤醒。
4. 通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式。

# 介绍一下Spring，讲一下Spring源码的大致过程

1. Spring是一个快速开发框架，Spring帮助程序员来管理对象
2. Spring的源码是非常优秀的，设计模式的应用、并发安全的实现、面向接口的设计等
3. 在创建Spring容器，也就是启动Spring时：
   1. 首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中。
   2. 然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建
   3. 利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤、其中AOP就是发生在初始化后这一步骤中
4. 单例Bean创建完了之后，Spring会发布一个容器启动事件
5. Spring启动结束
6. 在源码中会更加复杂，比如源码会提供一些模板方法，让子类实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BeanFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的
7. 在Spring启动过程中还会去处理@Import等注解

# Spring的事务机制

1. Spring的事务底层是基于数据库事务和AOP机制的
2. 首先对于使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean
3. 当调用代理对象的方法时，会先判断该方法是否加了@Transactional注解
   1. 如果加了，那么则利用事务管理器创建一个数据库连接，并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步。然后执行当前方法，方法中会执行sql。执行完当前方法后，如果没有出现异常就直接提交事务。
   2. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务。
4. Spring事务的隔离级别对应的就是数据库的隔离级别。
5. Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的。Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上

# HashMap的put方法

1. 根据Key通过  哈希算法 跟  与运算 得出数组下标。
2. 如果数组下标位置元素为空，则将Key和Value封
3. 装为Node对象(JDK1.7是Entry对象),并放入该位置。
4. 如果该位置不为空的话则分情况讨论：
   1. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容则进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中。
   2. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node还是链表Node。
      1. 如果是红黑树Node，则会将Key和Value封装为一个红黑树节点并添加到红黑树中去,在这个过程中会判断红黑树中是否存在相同的Key,如果存在则更新Value。
      2. 如果是链表Node，则会将Key和Value封装为一个链表Node并通过尾插法插入到链表的最后去，因为使用尾插法，所以会遍历链表，在遍历过程中，如果存在相同的Key，则更新Value，否则遍历完后，将新链表Node插入到链表中。当插入后，会查看链表的节点个数，如果>=8个，则会将该链表转化为红黑树。
      3. 将Node插入红黑树或者链表后，在判断是否需要扩容，如果需要则进行扩容，如果不需要则结束put方法。   

# HashMap1.7到1.8的变化

1. jdk1.7中底层是数组+链表,1.8中是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的整体效率。
2. 1.7中链表插入使用头插法，1.8中链表插入使用尾插法，因为1.8中插入Node对象时候需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以直接使用尾插法。
3. 1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提高HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。

# jdk1.7-1.8中虚拟机的变化

1.7中存在永久代，1.8中删除了永久代，替代永久代的是元空间，元空间所占的内存不在虚拟机内部，而是本地内存中，这么做的原因是：不管是永久代还是元空间都是方法区的具体实现，之所以元空间所占的内存改为本地内存，官方的说法是为了和JRockit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的大小是比较难指定的，太小了容易出现方法区溢出，太大了又会太多虚拟机的内存空间，所以转移到本地内存中，就不会影响到虚拟机所占用的内存。

# 常用的SpringBoot注解

1. SpringBootApplication注解：这个注解标识了一个SpringBoot工程，它实际上是三个注解的组合，分别是
   1. @SpringBootConfiguration：这个注解实际上就是一个@Configuration，表示启动类也是一个配置类
   2. @EnableAutoConfiguration：向Spring容器中导入了一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动配置加载为配置Bean
   3. @ComponentScan：标识扫描路径，默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录。
2. @Bean注解：用来定义Bean，类似于XML中的`<bean>`标签，Spring在启动时，会对加了@Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象
3. @Controller、@Service、@ResponseBody、@Autowired等等

# 分布式锁的实现

分布式锁要解决的问题的本质是：能够对分布在多台机器中的线程对共享资源的互斥访问。实现方式有：

1. 基于Mysql，分布式环境的线程连接同一个数据库，利用数据库中的行锁来达到互斥访问，但是Mysql 的加锁和释放锁的性能比较低，不适合真正的实际生产环境。
2. 基于Zookeeper，Zookeeper中的数据是存在于内存中的，所以相对于Mysql性能上来说是更加适合实际环境的，并且基于Zookeeper的顺序节点、临时节点、Watch机制能非常好的来实现的分布式锁
3. 基于Redis，Redis中的数据也是在内存，基于Redis的消费订阅功能、数据超时功能、lua脚本等功能，也能很好的实现分布式锁

# Redis的数据结构及使用场景

1. 字符串：可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID。
2. 哈希表：用来存储一些key-value对，更适合用来存储对象。
3. 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似公众号、微博等消息流数据。
4. 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现：我和某人共同关注的人、朋友圈点赞显示等功能。
5. 有序集合：集合是无需的，有序集合可以设置顺序，可以用来实现排行榜功能。

# Redis集群策略

1. 主从模式：这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连主库或者从库都可以。但是当主库或者从库宕机后，客户端需要手动修改IP，另外，这种模式也比较难进行扩容，整个集群所能存储的数据受限制于某台机器的内存容量，所以不能支持特大数据量。
2. 哨兵模式：这种模式在主从模式上新增了哨兵节点，当主库节点宕机后吗，哨兵会发现主库节点宕机，然后从库中选择一个库作为新的主库，另外哨兵也可以做集群，从而可以保证当某一个哨兵节点宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证Redis的高可用，但是仍然不能很好的解决Redis的容量上限的问题。
3. Cluster模式：Cluster模式是用的比较多的模式，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，则会从该主节点的从节点中选择一个当新的主节点。

如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且要持续的扩容，选择Cluster模式。

# Innodb是如何实现事务的

Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个update语句为例：

1. Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool 中
2. 执行 update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据
3. 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中
4. 针对 update 语句生成 undolog 日志，用于事务回滚
5. 如果事务提交，那么则把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中。
6. 如果事务回滚，则利用 undoLog 日志进行回滚

# 遇到过哪些设计模式

1. 代理模式：Mybatis中用到 JDK 动态代理来生成 Mapper 的代理对象，在执行代理对象的方法时会去执行 SQL、Spring中AOP、包括 @Configuration 注解的底层实现也都用到了代理模式。
2. 责任链模式：Tomcat 中的 Pipeline 实现，以及 Dubbo 中的 Filter 机制都使用了责任链模式。
3. 工厂模式：Spring 中的 BeanFactory 就是一种工厂模式的实现。
4. 适配器模式：Spring中的 Bean 销毁的生命周期中用到了适配器模式，用来适配各种 Bean 销毁逻辑的执行方式。
5. 外观模式：Tomcat 中的 Request 和 RequestFacade 之间体现的就是外观模式。
6. 模板方法模式：Spring中 的 refresh 方法中就提供了给子类继承重写的方法，就用到了模板方法模式。

# Java死锁如何避免

造成死锁的几个原因：

1. 一个资源每次只能被一个线程使用；
2. 一个线程在阻塞等待某个资源时，不释放已占有资源；
3. 一个线程已经获得的资源，在未使用完之前，不能被强行剥夺；
4. 若干线程形成头尾相接的循环等待资源关系。

这是造成死锁必须要达到的四个条件，如果要避免死锁，只需要不满足其中一个条件即可。而其中前三个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的情况。

在开发过程中：

1. 要注意加锁的顺序，保证每个线程按同样的顺序进行加锁。
2. 要注意加锁的时限，可以针对锁设置一个超时时间。
3. 要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决。

# 如果提交任务时，线程池队列满了会发生什么

1. 如果使用无界队列，那么可以继续提交任务。
2. 如果使用有界队列，提交任务时，如果线程池队列满了，并且核心线程数没有达到上限，那么则增加线程；如果核心线程数也达到了最大值，则使用拒绝策略进行拒绝。

