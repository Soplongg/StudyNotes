## 1. 引用计数法

​	每一个对象都有一个引用计数属性，当新增一个引用的时候+1，引用释放的时候-1，当计数为0的时候可以回收。

> 引用计数法可以出现A引用了B，B又引用了A,当两个都不再使用的使用,因为相互引用的原因,计数器 = 1，永远无法被回收

## 2. 可达性分析法

​	从 GC Roots  开始往下搜索,搜索所走过的路径称为引用链。当一个对象没有到 GC Roots 没有任何引用链连接时，则证明该对象是没有使用的，那么虚拟机就判断是可回收对象。

### GC Roots的对象有：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

​       可达性算法中不可达对象并非是立即死亡，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots 相连接的引用链，第二次是在由虚拟机自动建立的Finalizer中判断是否需要执行finalize( )方法。

​		当对象变成（GC Roots）不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。若已覆盖且对象未执行finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达则进行回收，否则，对象---------"复活"

> 每个对象只能触发一次finalize方法
>
> finalize方法运行代价高，不确定性大，无法保证各个对象的调用顺序，不推荐使用





