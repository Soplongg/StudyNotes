1. 根据Key通过  哈希算法 跟  与运算 得出数组下标。
2. 如果数组下标位置元素为空，则将Key和Value封
3. 装为Node对象(JDK1.7是Entry对象),并放入该位置。
4. 如果该位置不为空的话则分情况讨论：
   1. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容则进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中。
   2. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node还是链表Node。
      1. 如果是红黑树Node，则会将Key和Value封装为一个红黑树节点并添加到红黑树中去,在这个过程中会判断红黑树中是否存在相同的Key,如果存在则更新Value。
      2. 如果是链表Node，则会将Key和Value封装为一个链表Node并通过尾插法插入到链表的最后去，因为使用尾插法，所以会遍历链表，在遍历过程中，如果存在相同的Key，则更新Value，否则遍历完后，将新链表Node插入到链表中。当插入后，会查看链表的节点个数，如果>=8个，则会将该链表转化为红黑树。
      3. 将Node插入红黑树或者链表后，在判断是否需要扩容，如果需要则进行扩容，如果不需要则结束put方法。   

